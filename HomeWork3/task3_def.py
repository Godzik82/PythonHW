def get_max_row(row):
    max_row = 0
    count = 0

    for elm in row:
        if elm == '0':
            count += 1
            max_row = count if count > max_row else max_row
        elif elm == '1':
            count = 0
    return max_row

def get_index(max_row, row):
    if max_row > 0:
        place = row.find('0' * max_row)
    else:
        place = -1

    if place == 0 or max_row == 1:
        return place
    elif place == len(row) - max_row:
        return len(row) - 1
    elif place == -1:
        return 'Все места заняты'
    else:
        return  place + max_row // 2

def task3():
    print('''3* - самая простоя задача, которую мне давали при собесе в Яндекс.
    есть список состоящий из элементов 0 и 1. Например [0, 0, 0, 1, 0, 1] он может быть любой величины 
    и содержать любой количество нулей и единиц. Представьте что этот список моделирует ряд в кинотеатре
    где 0 - место не занято, 1 - место занято. Необходимо найти номер незанятого сидения (индекс элемента)
    при посадке на которое мы будем максимально удалены от других сидящих посетителей.
    Требования по памяти: O(1) - количество занимаемой дополнительными переменными памяти не изменяется
    в зависимости от размера переданного списка
    Требования по алгоритмической сложности - O(n) - один проход по списку\n''')
    row = input('Введите параметры ряда без проблелов - ')
    max_row = get_max_row(row)
    print('Наиболее удаленное место - ' + str(get_index(max_row, row)))